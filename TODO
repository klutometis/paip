# -*- org -*-
* 1
  We could reverse the name, and play the first-name trick; I'd like
  to recurse, though, and backtrack when we encounter something in
  =*suffices*=.

  Pathological case when the only same is e.g. `Jr.'? `Jr.' is the
  result.

  #+BEGIN_SRC lisp :tangle 1.1.lisp :shebang #!/usr/local/bin/sbcl --script
    (defvar *names*
      '((John Q Public)
        (Malcom X)
        (Admiral Grace Murray Hopper)
        (Spot)
        (Aristotle)
        (A A Milne)
        (Z Z Top)
        (Sir Larry Olivier)
        (Miss Scarlet)
        (Rex Morgan MD)
        (Morton Downey Jr.))
      "List of names upon which to test")
    
    (defparameter *suffices*
      '(Jr. MD))
    
    (defun last-name (name)
      "Select the last name from a name represented as a list."
      (reduce (lambda (penultimate-name ultimate-name)
                (if (member ultimate-name *suffices*)
                    penultimate-name
                    ultimate-name))
              name))
    
    (assert (equal
             (mapcar #'last-name *names*)
             '(PUBLIC X HOPPER SPOT ARISTOTLE MILNE TOP OLIVIER SCARLET MORGAN DOWNEY)))
  #+END_SRC

  #+BEGIN_SRC lisp :tangle 1.2.lisp :shebang #!/usr/local/bin/sbcl --script
    (defun exponentiate (base power)
      (if (zerop power)
          1
          (* base (exponentiate base (- power 1)))))
    
    (assert (= (exponentiate 3 2) 9))
  #+END_SRC

  Some things implicit in this solution: if it's not =null=, it's a
  list; of it's not =listp=, it's an atom.

  #+BEGIN_SRC lisp :tangle 1.3.lisp :shebang #!/usr/local/bin/sbcl --script
    (defun count-atoms (expression)
      (if (null expression)
          0
          (let ((elt (car expression)))
            (+ (if (listp elt) (count-atoms elt) 1)
               (count-atoms (cdr expression))))))
    
    (assert (= (count-atoms '(a (b d) c)) 4))    
  #+END_SRC

  How does this behave when =computor= is itself a list?

  #+BEGIN_SRC lisp :tangle 1.4.lisp :shebang #!/usr/local/bin/sbcl --script
    (defun count-anywhere (computor computandum)
      (if (null computandum)
          0
          (let ((elt (car computandum)))
            (+ (if (listp elt) (count-anywhere computor elt) (if (eql computor elt) 1 0))
               (count-anywhere computor (cdr computandum))))))
    
    (assert (= (count-anywhere 'a '(a ((a) b) a)) 3))
  #+END_SRC

  We'll map the lists, producing an initial product; then reduce by
  addition.

  #+BEGIN_SRC lisp :tangle 1.5.lisp :shebang #!/usr/local/bin/sbcl --script
    (defun dot-product (x y)
      "Compute the dot product, where x and y are lists of integers."
      (apply #'+ (mapcar #'* x y)))
    
    (assert (= (dot-product '(10 20) '(3 4)) 110))
  #+END_SRC

** 1.2

   - context-free phrase-structure grammar
   - generative syntax
   - thus, they are not functions in the mathematical sense, but they
     are called functions in lisp, because they return a value.
   - all functions in grammar, list of words; apply append.
   - think of the position numbers as telling you how far you are from
     the front.
     - pretty good advice
   - i include the symbol =->=, even though it serves no real purpose;
     it is purely decorative.

   #+BEGIN_QUOTE
   #+BEGIN_SRC lisp
     (defparamter *simple-grammar*
         '((sentence -> (noun-phrase verb-phrase))
           ...)
       "Trivial grammar")
     
     (defvar *grammar* *simple-grammar*
       "The grammar used; intitially trivial, but we can elaborate.")
   #+END_SRC
   #+END_QUOTE

   - a variable is routinely changed during the course of running the
     program; a paramemter will normally stay constant.
   - a change to a parameter is considered a change to the program,
     not by the program.
     - what about when the generatedc word happens to correspond to a
      rule; e.g.  sentence, Article?

   #+BEGIN_QUOTE
   #+BEGIN_SRC lisp
     (defun generate (phrase)
       "Generate a random sentence or phrase"
       (cond ((listp phrase)
              (mappend #'generate phrase))
             ((rewrites phrase)
              (generate (ransom-elt (rewrites phrase))))
             (t (list phrase))))
   #+END_SRC
   #+END_QUOTE

   - data-driven programming: data (rewrites associated with
     category) drives what the prgoram does next.
   - concise and extensible: add a new association without having to
     modify the program.
   - with if instead of cond:

   #+BEGIN_QUOTE
   #+BEGIN_SRC lisp
     (defun generate (phrase)
       "Generate a random sentence or phrase"
       (if (listp phrase)
           (mappend #'generate phrase)
           (let ((choices (rewrites phrase)))
             (if (null choices)
                 (list phrase)
                 (generate (random-elt choices))))))
   #+END_SRC
   #+END_QUOTE
